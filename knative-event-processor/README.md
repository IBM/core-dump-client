# knative-event-processor

This is a **proof of concept** to demonstrate how a core dump can be integrated into a [gitops](https://docs.openshift.com/constainer-platform/4.7/cicd/gitops/understanding-openshift-gitops.html) workflow. It uses an event raised when a core dump is generated in a cloud object store to create a [gitpod.io](https://www.gitpod.io/) container definition that integrates the `default` container in the root of the `core-dump-client` project to a pull request on a repo.


## Local execution

After executing `npm install`, you can run this function locally by executing `npm run local`.

The runtime will expose three endpoints.

  * `/` The endpoint for your function.
  * `/health/readiness` The endpoint for a readiness health check
  * `/health/liveness` The endpoint for a liveness health check

The parameter provided to the function endpoint at invocation is a `Context` object containing HTTP request information.

```js
function handleRequest(context) {
  const log = context.log;
  log.info(context.httpVersion);
  log.info(context.method); // the HTTP request method (only GET or POST supported)
  log.info(context.query); // if query parameters are provided in a GET request
  log.info(context.body); // contains the request body for a POST request
  log.info(context.headers); // all HTTP headers sent with the event
}
```

Where the `context.body` is an implementation of the `ibm-cos-event-schema.json`
```json
{  
    "bucket": "core-storage",  
    "endpoint": "",  
    "key": "3927906d-5b6d-4ff8-8a61-937bcada155b-dump-1643657577-segfaulter-segfaulter-1-4.zip",  
    "notification": {  
      "bucket_name": "core-storage",  
      "content_type": "application/octet-stream",  
      "event_type": "Object:Write",  
      "format": "2.0",  
      "object_etag": "f68a47ca5da37992f024695d1fdf38fb",  
      "object_length": "28336",  
      "object_name": "3927906d-5b6d-4ff8-8a61-937bcada155b-dump-1643657577-segfaulter-segfaulter-1-4.zip",  
      "request_id": "8a1186ad-c2fe-4830-b98f-c302d7caca0a",  
      "request_time": "2022-01-31T19:32:59.395Z"  
    },  
    "operation": "Object:Write"  
  }
```

The health checks can be accessed in your browser at [http://localhost:8080/health/readiness]() and [http://localhost:8080/health/liveness](). You can use `curl` to `POST` an event to the function endpoint:

```console
curl -X POST -d '{"hello": "world"}' \
  -H'Content-type: application/json' \
  http://localhost:8080
```

The readiness and liveness endpoints use [overload-protection](https://www.npmjs.com/package/overload-protection) and will respond with `HTTP 503 Service Unavailable` with a `Client-Retry` header if your function is determined to be overloaded, based on the memory usage and event loop delay.

## Testing

This function project includes a [unit test](./test/unit.js) and an [integration test](./test/integration.js). All `.js` files in the test directory are run.

Currently testing is a little manual.

1. Create a core dump 

```console
kubectl run -i -t segfaulter --image=quay.io/icdh/segfaulter --restart=Never -l info.coredump.owner=no9,info.coredump.repo=segfaulter
```

2. Update the `test/body.json` file with the name of the zip file and the bucket value to match your environment.

```json
"bucket": "core-storage", 
"key": "3927906d-5b6d-4ff8-8a61-937bcada155b-dump-1643657577-segfaulter-segfaulter-1-4.zip", 
```

Then run npm test.

```console
npm test 
```
The test could be smoothed out by changing the name generated by the core-dump-handler to be a static string using the template feature.
but the logic for creating the pull request id would have to be modified.
